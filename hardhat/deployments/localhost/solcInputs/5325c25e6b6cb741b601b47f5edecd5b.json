{
  "language": "Solidity",
  "sources": {
    "contracts/Certificate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// import \"./ApiGenerate.sol\";\r\n\r\ncontract Certificate {\r\n  // admin\r\n  address public owner;\r\n\r\n  // ApiGenerate api = new ApiGenerate();\r\n\r\n  // customer of API are institute and Validators\r\n  enum Role_Access {\r\n    Normal_User,\r\n    Student,\r\n    ThirdPartyValidator,\r\n    University,\r\n    Admin\r\n  }\r\n  // event\r\n  event RoleAssigned(address indexed user, Role_Access role_assigned);\r\n  event ApiGenerates(address indexed user, string apiKey);\r\n  event CertificateIssued(\r\n    address indexed _owner,\r\n    string documentUrl,\r\n    string uniqueId\r\n  );\r\n  event CertificateValidate(\r\n    address indexed _issuer,\r\n    address indexed _owner,\r\n    string documentUrl,\r\n    string indexed uniqueId,\r\n    string remarks\r\n  );\r\n\r\n  // struct of user\r\n  struct User {\r\n    address userId;\r\n    Role_Access role_assigned;\r\n    string universityName;\r\n    bool isValid;\r\n  }\r\n\r\n  struct CertificateDetail {\r\n    address owner;\r\n    address issuer;\r\n    string documentUrl;\r\n    string uniqueId;\r\n    string courseId;\r\n    string remarks;\r\n    bool isValid;\r\n  }\r\n\r\n  // Mappings\r\n\r\n  // Access Mapping\r\n  mapping(address => Role_Access) public userPermission;\r\n  mapping(address => User) private userDetail;\r\n  mapping(address => string) private apiKeys;\r\n\r\n  // Certificate mapping\r\n  mapping(address => CertificateDetail[]) private userCertificates;\r\n  mapping(string => CertificateDetail) private certificateDetails;\r\n  mapping(string => address) private certificateIssuer;\r\n\r\n  // intialize contract and assign admin\r\n  constructor() {\r\n    owner = msg.sender;\r\n    userPermission[msg.sender] = Role_Access.Admin;\r\n    emit RoleAssigned(msg.sender, Role_Access.Admin);\r\n  }\r\n\r\n  // modifier for authenticate\r\n  modifier canAccess(Role_Access role) {\r\n    // here those user can access who have more permissions\r\n    require(userPermission[msg.sender] >= role, \"You are unauthorize\");\r\n    _;\r\n  }\r\n\r\n  // assign role or change role\r\n  function modifyRole(\r\n    address _user,\r\n    Role_Access _newRole\r\n  ) external canAccess(Role_Access.Admin) {\r\n    /** are we giving role to student */\r\n    userPermission[_user] = _newRole;\r\n    emit RoleAssigned(_user, _newRole);\r\n  }\r\n\r\n  function generateApiKey(\r\n    address _user,\r\n    string memory _universityName,\r\n    Role_Access _role\r\n  ) external canAccess(Role_Access.Admin) {\r\n    User memory newUser = User({\r\n      userId: _user,\r\n      role_assigned: _role,\r\n      universityName: _universityName,\r\n      isValid: true\r\n    });\r\n\r\n    // bytes32 _apiToken = api.generateApiToken(_universityName);\r\n\r\n    userDetail[_user] = newUser;\r\n    // apiKeys[_user] = string(_apiToken);\r\n    userPermission[_user] = _role;\r\n    apiKeys[_user] = \"api_key_gtu\";\r\n  }\r\n\r\n  /* why function is internal and not used */\r\n  function verifyApiKey(string memory apiKey) internal view returns (address) {\r\n    if (keccak256(bytes(apiKeys[msg.sender])) == keccak256(bytes(apiKey))) {\r\n      return msg.sender; /* why return msg.sender, why not true or false */\r\n    }\r\n\r\n    return address(0);\r\n  }\r\n\r\n  function generateCertificate(\r\n    address _owner,\r\n    string memory _documentUrl,\r\n    string memory _uniqueId,\r\n    string memory _courseId,\r\n    string memory _remark\r\n  ) external canAccess(Role_Access.University) {\r\n    // check issuer is registerd or not\r\n\r\n    CertificateDetail memory dummyCertificate = CertificateDetail({\r\n      owner: _owner,\r\n      issuer: msg.sender,\r\n      documentUrl: _documentUrl,\r\n      uniqueId: _uniqueId,\r\n      courseId: _courseId,\r\n      remarks: _remark,\r\n      isValid: true\r\n    });\r\n\r\n    // map certificate with user\r\n    userCertificates[_owner].push(dummyCertificate);\r\n\r\n    // map detail with id\r\n    certificateDetails[_uniqueId] = dummyCertificate;\r\n\r\n    // map certificate id with university\r\n    certificateIssuer[_uniqueId] = msg.sender;\r\n\r\n    emit CertificateIssued(_owner, _documentUrl, _uniqueId);\r\n  }\r\n\r\n  function getCertificateDetail(\r\n    string memory _certId\r\n  ) public view returns (CertificateDetail memory) {\r\n    require(userCertificates[msg.sender].length > 0, \"Unauthorize access\");\r\n\r\n    return certificateDetails[_certId];\r\n  }\r\n\r\n  function getMyAllCertificates()\r\n    public\r\n    view\r\n    returns (CertificateDetail[] memory)\r\n  {\r\n    require(userCertificates[msg.sender].length > 0, \"Unauthorize access\");\r\n    return userCertificates[msg.sender];\r\n  }\r\n\r\n  function validateCertificate(\r\n    string memory _certId\r\n  ) public canAccess(Role_Access.ThirdPartyValidator) returns (bool) {\r\n    CertificateDetail memory detail = certificateDetails[_certId];\r\n    if (detail.isValid) {\r\n      /** no need to emit CertificateValidate */\r\n      emit CertificateValidate(\r\n        detail.issuer,\r\n        detail.owner,\r\n        detail.documentUrl,\r\n        detail.uniqueId,\r\n        detail.remarks\r\n      );\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function discardCertficate(\r\n    address _student,\r\n    string memory _certId\r\n  ) public canAccess(Role_Access.University) {\r\n    require(\r\n      certificateIssuer[_certId] == msg.sender,\r\n      \"Unauthorize to made changes\"\r\n    );\r\n\r\n    for (uint i; i < userCertificates[_student].length; i++) {\r\n      if (\r\n        keccak256(bytes(userCertificates[_student][i].uniqueId)) ==\r\n        keccak256(bytes(_certId))\r\n      ) {\r\n        userCertificates[_student][i].isValid = false;\r\n        certificateDetails[_certId].isValid = false;\r\n      }\r\n    }\r\n  }\r\n  // function getRole() to know which role is assigned to individual\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}